{
    "docs": [
        {
            "location": "/",
            "text": "Summary\n\n\nWish brings \nselectable return values\n to Python.\n\n\n\n\nOverview\n\u00b6\n\n\nIt's already very easy to deal with functions\nhaving several possible sets of arguments in Python.\nWhy? Because the language supports natively:\n\n\n\n\ndefault argument values\n\n\nkeyword arguments\n\n\nargument unpacking\n\n\n\n\nNow for return values, beyond tuples to deal with multiple values. \nUsing functions that return many values is often tedious.\nWish provides \nselectable return values\n to solve this issue.\n\n\nQuickstart\n\u00b6\n\n\n\n\n\n\nInstall wish with pip (\ninstructions\n).\n\n\n\n\n\n\nReplace your function with many arguments \nf\n with\n\n\ndef f(...):\n    ...\n    return a, b, c, ..., z\n\n\n\nwith\n\n\nimport wish\n\ndef f(..., returns=\"a, b\"):\n    ...\n    return wish.grant(returns)\n\n\n\n\n\n\n\nUpdate the documentation of your function\n\n\n\n\nParameters:\n\n\n\n\n\n\n...\n\n\n\n\n\n\nreturns\n: string, optional.\n    Select the returned values, among \na\n, \nb\n, ..., \nz\n.\n    Default is \n\"a, b\"\n.\n\n\n\n\n\n\nReturns:\n\n\n\n\n\n\na\n: ...\n\n\n\n\n\n\nb\n: ...\n\n\n\n\n\n\nc\n: ..., not returned by default\n\n\n\n\n\n\n...\n\n\n\n\n\n\nz\n: ..., not returned by default\n\n\n\n\n\n\n\n\n\n\n\n\nUse the flexibility of the new API\n\n\n >>> a, b = f(...)\n >>> w, i, s, h = f(..., returns=\"w, i, s, h\")",
            "title": "Getting Started"
        },
        {
            "location": "/#overview",
            "text": "It's already very easy to deal with functions\nhaving several possible sets of arguments in Python.\nWhy? Because the language supports natively:   default argument values  keyword arguments  argument unpacking   Now for return values, beyond tuples to deal with multiple values. \nUsing functions that return many values is often tedious.\nWish provides  selectable return values  to solve this issue.",
            "title": "Overview"
        },
        {
            "location": "/#quickstart",
            "text": "Install wish with pip ( instructions ).    Replace your function with many arguments  f  with  def f(...):\n    ...\n    return a, b, c, ..., z  with  import wish\n\ndef f(..., returns=\"a, b\"):\n    ...\n    return wish.grant(returns)    Update the documentation of your function   Parameters:    ...    returns : string, optional.\n    Select the returned values, among  a ,  b , ...,  z .\n    Default is  \"a, b\" .    Returns:    a : ...    b : ...    c : ..., not returned by default    ...    z : ..., not returned by default       Use the flexibility of the new API   >>> a, b = f(...)\n >>> w, i, s, h = f(..., returns=\"w, i, s, h\")",
            "title": "Quickstart"
        },
        {
            "location": "/installation/",
            "text": "Python 2\n\u00b6\n\n\nWish supports Python 2.7.\nMake sure that the \npip\n package installer is available for it\n\n\n$ pip --version\npip 9.0.1 from /usr/local/lib/python2.7/dist-packages (python 2.7)\n\n\n\nand install wish\n\n\n$ pip install wish\n\n\n\nPython 3\n\u00b6\n\n\n\n\nWarning\n\n\nWish does not support Python 3 (yet).\n\n\n\n\nIf you want to install wish (for Python 2) but \npip\n refers to your Python 3 \ninterpreter\n\n\n$ pip --version\npip 9.0.1 from /usr/local/lib/python3.5/dist-packages (python 3.5)\n\n\n\nthen you may have a version of pip for Python 2 installed.\nIt may be named \npip2\n or \npip2.7\n; you can use it to install wish.\nOtherwise, refer to your Python 2 interpreter explicitly: \nif it is named \npython\n\n\n$ python --version\nPython 2.7.12\n\n\n\nthen install pip for Python 2 with\n\n\n$ python -m pip install --upgrade pip\n\n\n\nand finally install wish\n\n\n$ python -m pip install wish",
            "title": "Installation"
        },
        {
            "location": "/installation/#python-2",
            "text": "Wish supports Python 2.7.\nMake sure that the  pip  package installer is available for it  $ pip --version\npip 9.0.1 from /usr/local/lib/python2.7/dist-packages (python 2.7)  and install wish  $ pip install wish",
            "title": "Python 2"
        },
        {
            "location": "/installation/#python-3",
            "text": "Warning  Wish does not support Python 3 (yet).   If you want to install wish (for Python 2) but  pip  refers to your Python 3 \ninterpreter  $ pip --version\npip 9.0.1 from /usr/local/lib/python3.5/dist-packages (python 3.5)  then you may have a version of pip for Python 2 installed.\nIt may be named  pip2  or  pip2.7 ; you can use it to install wish.\nOtherwise, refer to your Python 2 interpreter explicitly: \nif it is named  python  $ python --version\nPython 2.7.12  then install pip for Python 2 with  $ python -m pip install --upgrade pip  and finally install wish  $ python -m pip install wish",
            "title": "Python 3"
        },
        {
            "location": "/numerical-differentiation/",
            "text": "The Classic API\n\u00b6\n\n\nConsider the following use case: the computation of the\n(approximate) derivative of a function with Newton's difference quotient:\n\n\ndef d(f, x, h=1e-13):\n    dq = (f(x + h) - f(x)) / h\n    return dq\n\n\n\nThis function \nd\n would typically be used like this:\n\n\n>>> from math import sin\n>>> d(sin, x=0.0)\n0.9999999999999983\n\n\n\nNow, an improved version of \nd\n would compute an error estimate \nerror\n\n\ndef d(f, x, h=1e-7):\n    dq = (f(x + h) - f(x)) / h\n    dq2 = (f(x + 0.5*h) - f(x)) / (0.5*h)\n    error = 2 * (dq - dq2)\n    return dq, error\n\n\n\nwhose usage would be\n\n\n>>> d(sin, x=0.0)\n(0.9999999999999983, -2.4424906541753444e-15)\n\n\n\nWhile this is a sound idea to provide an error estimate, \nwe have broken the original API. \nNow, in the simplest and more common use case,\nwhen we do not care about the error, \nthe code is more complex than it should be\n1\n:\n\n\n>>> import math\n>>> dq, _ = d(sin, x=0.0)\n>>> dq \n0.9999999999999983\n\n\n\nWith Wish\n\u00b6\n\n\nTo get a decent API in both cases, we may use wish and\nspecify in the function signature an extra argument that lists the value(s) \nreturned by default\n\n\ndef d(f, x, h=1e-7, returns=\"dq\"):\n    dq = (f(x + h) - f(x)) / h\n    dq2 = (f(x + 0.5*h) - f(x)) / (0.5*h)\n    error = 2 * (dq - dq2)\n    return wish.grant(returns)\n\n\n\nWith this pattern, the common case is still simple\n\n\n>>> d(sin, x=0.0)\n0.9999999999999983\n\n\n\nbut the more complex case is possible and the intent is explicit:\n\n\n>>> d(sin, x=0.0, returns=\"dq, error\")\n(0.9999999999999983, -2.4424906541753444e-15)\n\n\n\n\n\n\n\n\n\n\n\nConventionally, a variable is named \n_\n if its value is ignored.\u00a0\n\u21a9",
            "title": "Numerical Differentiation"
        },
        {
            "location": "/numerical-differentiation/#the-classic-api",
            "text": "Consider the following use case: the computation of the\n(approximate) derivative of a function with Newton's difference quotient:  def d(f, x, h=1e-13):\n    dq = (f(x + h) - f(x)) / h\n    return dq  This function  d  would typically be used like this:  >>> from math import sin\n>>> d(sin, x=0.0)\n0.9999999999999983  Now, an improved version of  d  would compute an error estimate  error  def d(f, x, h=1e-7):\n    dq = (f(x + h) - f(x)) / h\n    dq2 = (f(x + 0.5*h) - f(x)) / (0.5*h)\n    error = 2 * (dq - dq2)\n    return dq, error  whose usage would be  >>> d(sin, x=0.0)\n(0.9999999999999983, -2.4424906541753444e-15)  While this is a sound idea to provide an error estimate, \nwe have broken the original API. \nNow, in the simplest and more common use case,\nwhen we do not care about the error, \nthe code is more complex than it should be 1 :  >>> import math\n>>> dq, _ = d(sin, x=0.0)\n>>> dq \n0.9999999999999983",
            "title": "The Classic API"
        },
        {
            "location": "/numerical-differentiation/#with-wish",
            "text": "To get a decent API in both cases, we may use wish and\nspecify in the function signature an extra argument that lists the value(s) \nreturned by default  def d(f, x, h=1e-7, returns=\"dq\"):\n    dq = (f(x + h) - f(x)) / h\n    dq2 = (f(x + 0.5*h) - f(x)) / (0.5*h)\n    error = 2 * (dq - dq2)\n    return wish.grant(returns)  With this pattern, the common case is still simple  >>> d(sin, x=0.0)\n0.9999999999999983  but the more complex case is possible and the intent is explicit:  >>> d(sin, x=0.0, returns=\"dq, error\")\n(0.9999999999999983, -2.4424906541753444e-15)      Conventionally, a variable is named  _  if its value is ignored.\u00a0 \u21a9",
            "title": "With Wish"
        },
        {
            "location": "/svd/",
            "text": "Summary\n\n\nWe redesign the API of the SVD function of SciPy\nwith wish to demonstrate the method and its benefits.\n\n\n\n\nContext\n\u00b6\n\n\nThe \nSciPy\n library \nimplements \nsingular value decomposition\n\n(SVD),\na matrix factorization that is instrumental\nin numerical analysis, machine learning and data science.\nThe SVD of a matrix \n\\(A \\in \\mathbb{C}^{m \\times n}\\)\n \nis a triple \n\\((U, \\Sigma, V)\\)\n such that\n  $$\n  A = U \\Sigma V^{\\ast}\n  $$\nwhere \n\\(U \\in \\mathbb{C}^{m \\times m}\\)\n and \n\\(V \\in \\mathbb{C}^{n \\times n}\\)\n\nare \nunitary matrices\n, \n\\(V^{\\ast}\\)\n denotes the \nconjugate transpose\n of \n\\(V\\)\n \nand \n\\(\\Sigma \\in \\mathbb{C}^{m \\times n}\\)\n is a \ndiagonal matrix\n \n(filled with zeros outside of its main diagonal)\nwhose diagonal coefficients \n\\(\\sigma_k\\)\n\n-- called the \nsingular values\n of \n\\(A\\)\n --\nare real and satisfy\n\n\n$$\n  \\sigma_1 \\geq \\sigma_2 \\geq \\dots \\geq \\sigma_k \\geq \\dots \\geq 0\n  $$\n\n\nBasic API\n\u00b6\n\n\nThe \nsvd\n function of SciPy works like this: you provide the matrix \nA\n\nand it computes a matrix \nU\n, a vector \ns\n and a matrix \nVh\n1\n:\n\n\n>>> from scipy.linalg import svd\n>>> U, s, Vh = svd(A)\n\n\n\nThe default convention deviates a little from the definition of the SVD:\nthe vector \ns\n is the diagonal of \n\\(\\Sigma\\)\n instead of \n\\(\\Sigma\\)\n itself\nand \nVh\n corresponds to the conjugate transpose of \n\\(V\\)\n instead of \n\\(V\\)\n.\n\n\nWhile there are good reasons for these conventions, \nI'd rather follow the \nprinciple of least astonishment\n.\nThus, by default our SVD\nimplementation returns the triple \n\\((U, \\Sigma, V)\\)\n:\n\n\n>>> from wish.examples import svd\n>>> U, S, V = w.svd(A)\n\n\n\nBut if you want to follow SciPy conventions instead, \nit's rather simple since we may select the return values:\n\n\n>>> U, s, Vh = w.svd(A, returns=\"U, s, Vh\")\n\n\n\nTODO:\n explain how we do that !!! Refer to the pattern name, the\ntoy example of the source of the result? Explain also how to avoid\nunnecessary computations? Yeah, do goals sections and implementation \nsection\n\n\nSingular Values\n\u00b6\n\n\nWe frequently need to compute only the singular values of a matrix.\nThe scipy \nsvd\n achieves this with an additional option \ncompute_uv\n \nthat can be set to \nFalse\n as describe in the documentation:\n\n\n\n\ncompute_uv: bool, optional.\n\n\nWhether to compute also \nU\n and \nVh\n in addition to \ns\n.\nDefault is True.\n\n\n\n\nIt is used like this:\n\n\n>>> from scipy.linalg import svd\n>>> s = svd(M, compute_uv=False)\n\n\n\nThis interface is not totally satisfactory: \nwhile we easily understand that we won't \ncompute -- and therefore won't return -- \nU\n and \nVh\n, \nit is not totally obvious what is returned. \nAnd if in the first place you were only interested \nin the \ns\n array, you may not know what \nU\n and \nVh\n are ...\nThere is nothing here that cannot be solved by reading \nthe documentation of \nsvd\n, but still this is not optimal.\nThe SciPy folks are apparently aware of this because they have implemented \na helper function, \nsvdvals\n, to avoid calling \nsvd\n in this case:\n\n\n\n\nsvdvals(a, overwrite_a=False, check_finite=True)\n\n\nCompute singular values of a matrix.\n\n\n\n\nWith \nsvdvals\n, we can simply do\n\n\n>>> from scipy.linalg import svdvals\n>>> s = svdvals(A)\n\n\n\nbut of course now, you have another function to remember of.\nAnd while it is a one-liner, its full documentation essentially \nduplicates the one of \nsvd\n.\n\n\nWith the wish version, the equivalent code is simply\n\n\n>>> from wish.examples import svd\n>>> s = svd(A, returns=\"s\")\n\n\n\nWe know what is returned and a no new function is necessary.\n\n\nReconstruction\n\u00b6\n\n\nSince SciPy \nsvd\n returns the diagonal of \n\\(\\Sigma\\)\n, \nit comes with the helper function \ndiagsvd\n to build\n\n\\(\\Sigma\\)\n from the singular values:\n\n\n\n\ndiagsvd(s, M, N)\n\n\nConstruct the sigma matrix in SVD from singular values and size \nM\n, \nN\n.\n\n\n\n\nIt is used like this:\n\n\n>>> U, s, Vh = svd(A)\n>>> S = diagsvd(s, shape(U)[1], shape(Vh)[0])\n\n\n\nThe matrix \nS\n is typically used to reconstruct \nA\n:\n\n\n>>> from numpy import dot\n>>> A = dot(U, dot(S, Vh))\n\n\n\nOf course with the wish-enabled version, the same effect is obtained with\n\n\n>>> from wish.examples import svd\n>>> U, S, Vh = wsvd(A, returns=\"U, S, Vh\")\n>>> A = dot(U, dot(S, Vh))\n\n\n\n\n\nNow, if you don't want to reconstruct the matrix \nA\n but a version of it\nbased on a different set of singular values -- for example to achieve\nsome \ndimensionality reduction\n \n-- this is easy because NumPy already provides \nthe appropriate functions. First, get the singular values with\n\n\n>>> U, S, Vh = w_svd(A, returns=\"U, S, Vh\")\n>>> s = numpy.diagonal(S)\n\n\n\nor even with\n\n\n>>> U, S, Vh, s = w_svd(A, returns=\"U, S, Vh, s\")\n\n\n\nthen replace the vector of singular values \ns\n\nwith a modified vector \ns2\n and inject the result in \nS\n\n\n>>> s2 = ...\n>>> from numpy import fill_diagonal\n>>> fill_diagonal(S, s)\n>>> A2 = dot(U, dot(S, Vh))\n\n\n\nThe New API\n\u00b6\n\n\nThe redesigned \nsvd\n function now has arguably a simpler and more consistent\ninterface:\n\n\n\n\n\n\nThe simplest and most common usage follows closely the domain conventions,\n\n\n\n\n\n\nThe \"configurable return values\" pattern is supported\n     with the extra parameter \nreturns\n\n\n\n\n\n\nThe ad hoc parameter \ncompute_uv\n is not needed anymore.\n\n\n\n\n\n\nTwo helper functions \nsvdvals\n and \ndiagsvd\n are not needed anymore\n\n\n\n\n\n\n\n\n\nThe description of parameters and returned values is only slightly different\n2\n:\n\n\n\n\nParameters\n\n\n\n\n\n\na\n: \n(M, N)\n array_like\n\n\nMatrix to decompose.\n\n\n\n\n\n\n... \n\n\n\n\n\n\nreturns\n: \nstring\n, optional \n\n\nSelect the returned values, among \nU\n, \nS\n, \ns\n, \nV\n and \nVh\n.\nDefault is \n\"U, S, V\"\n.\n\n\n\n\n\n\n\n\n\n\nReturns\n\n\nThe selection of return values is configurable with the \nreturns\n parameter.\n\n\n\n\n\n\nU\n: \nndarray\n\n\nUnitary matrix having left singular vectors as columns.\n\n\n\n\n\n\nS\n : \nndarray\n\n\nA matrix with the singular values of \na\n, sorted in non-increasing\norder, in the main diagonal and zeros elsewhere.\n\n\n\n\n\n\nV\n: \nndarray\n\n\nUnitary matrix having right singular vectors as columns.\n\n\n\n\n\n\ns\n: \nndarray\n, not returned by default\n\n\nThe singular values, sorted in non-increasing order.\n\n\n\n\n\n\nVh\n: \nndarray\n, not returned by default\n\n\nConjugate transpose of \nV\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFor example, if\n\n\n  >>> A = [[ 0.0, -2.0,  0.0],\n  ...      [ 1.0,  0.0,  0.0]]\n\n\n\nthen \n\n\n  >>> U\n  array([[1.,  0.],\n        [ 0.,  1.]])\n  >>> s \n  array([ 2.,  1.])\n  >>> Vh \n  array([[ 0., -1.,  0.],\n         [ 1.,  0.,  0.],\n         [ 0.,  0.,  1.]])\n\n\n\n\u21a9\n\n\n\n\n\n\nwe have omitted any reference to the the parameters \n  \nfull_matrices\n, \noverwrite_a\n, \ncheck_finite\n and \nlapack_driver\n \n  since the behavior of \nsvd\n has not changed in this respect.\n  Refer to the \nScipy documentation\n for details.\u00a0\n\u21a9",
            "title": "Singular Value Decomposition"
        },
        {
            "location": "/svd/#context",
            "text": "The  SciPy  library \nimplements  singular value decomposition \n(SVD),\na matrix factorization that is instrumental\nin numerical analysis, machine learning and data science.\nThe SVD of a matrix  \\(A \\in \\mathbb{C}^{m \\times n}\\)  \nis a triple  \\((U, \\Sigma, V)\\)  such that\n  $$\n  A = U \\Sigma V^{\\ast}\n  $$\nwhere  \\(U \\in \\mathbb{C}^{m \\times m}\\)  and  \\(V \\in \\mathbb{C}^{n \\times n}\\) \nare  unitary matrices ,  \\(V^{\\ast}\\)  denotes the  conjugate transpose  of  \\(V\\)  \nand  \\(\\Sigma \\in \\mathbb{C}^{m \\times n}\\)  is a  diagonal matrix  \n(filled with zeros outside of its main diagonal)\nwhose diagonal coefficients  \\(\\sigma_k\\) \n-- called the  singular values  of  \\(A\\)  --\nare real and satisfy  $$\n  \\sigma_1 \\geq \\sigma_2 \\geq \\dots \\geq \\sigma_k \\geq \\dots \\geq 0\n  $$",
            "title": "Context"
        },
        {
            "location": "/svd/#basic-api",
            "text": "The  svd  function of SciPy works like this: you provide the matrix  A \nand it computes a matrix  U , a vector  s  and a matrix  Vh 1 :  >>> from scipy.linalg import svd\n>>> U, s, Vh = svd(A)  The default convention deviates a little from the definition of the SVD:\nthe vector  s  is the diagonal of  \\(\\Sigma\\)  instead of  \\(\\Sigma\\)  itself\nand  Vh  corresponds to the conjugate transpose of  \\(V\\)  instead of  \\(V\\) .  While there are good reasons for these conventions, \nI'd rather follow the  principle of least astonishment .\nThus, by default our SVD\nimplementation returns the triple  \\((U, \\Sigma, V)\\) :  >>> from wish.examples import svd\n>>> U, S, V = w.svd(A)  But if you want to follow SciPy conventions instead, \nit's rather simple since we may select the return values:  >>> U, s, Vh = w.svd(A, returns=\"U, s, Vh\")  TODO:  explain how we do that !!! Refer to the pattern name, the\ntoy example of the source of the result? Explain also how to avoid\nunnecessary computations? Yeah, do goals sections and implementation \nsection",
            "title": "Basic API"
        },
        {
            "location": "/svd/#singular-values",
            "text": "We frequently need to compute only the singular values of a matrix.\nThe scipy  svd  achieves this with an additional option  compute_uv  \nthat can be set to  False  as describe in the documentation:   compute_uv: bool, optional.  Whether to compute also  U  and  Vh  in addition to  s .\nDefault is True.   It is used like this:  >>> from scipy.linalg import svd\n>>> s = svd(M, compute_uv=False)  This interface is not totally satisfactory: \nwhile we easily understand that we won't \ncompute -- and therefore won't return --  U  and  Vh , \nit is not totally obvious what is returned. \nAnd if in the first place you were only interested \nin the  s  array, you may not know what  U  and  Vh  are ...\nThere is nothing here that cannot be solved by reading \nthe documentation of  svd , but still this is not optimal.\nThe SciPy folks are apparently aware of this because they have implemented \na helper function,  svdvals , to avoid calling  svd  in this case:   svdvals(a, overwrite_a=False, check_finite=True)  Compute singular values of a matrix.   With  svdvals , we can simply do  >>> from scipy.linalg import svdvals\n>>> s = svdvals(A)  but of course now, you have another function to remember of.\nAnd while it is a one-liner, its full documentation essentially \nduplicates the one of  svd .  With the wish version, the equivalent code is simply  >>> from wish.examples import svd\n>>> s = svd(A, returns=\"s\")  We know what is returned and a no new function is necessary.",
            "title": "Singular Values"
        },
        {
            "location": "/svd/#reconstruction",
            "text": "Since SciPy  svd  returns the diagonal of  \\(\\Sigma\\) , \nit comes with the helper function  diagsvd  to build \\(\\Sigma\\)  from the singular values:   diagsvd(s, M, N)  Construct the sigma matrix in SVD from singular values and size  M ,  N .   It is used like this:  >>> U, s, Vh = svd(A)\n>>> S = diagsvd(s, shape(U)[1], shape(Vh)[0])  The matrix  S  is typically used to reconstruct  A :  >>> from numpy import dot\n>>> A = dot(U, dot(S, Vh))  Of course with the wish-enabled version, the same effect is obtained with  >>> from wish.examples import svd\n>>> U, S, Vh = wsvd(A, returns=\"U, S, Vh\")\n>>> A = dot(U, dot(S, Vh))   Now, if you don't want to reconstruct the matrix  A  but a version of it\nbased on a different set of singular values -- for example to achieve\nsome  dimensionality reduction  \n-- this is easy because NumPy already provides \nthe appropriate functions. First, get the singular values with  >>> U, S, Vh = w_svd(A, returns=\"U, S, Vh\")\n>>> s = numpy.diagonal(S)  or even with  >>> U, S, Vh, s = w_svd(A, returns=\"U, S, Vh, s\")  then replace the vector of singular values  s \nwith a modified vector  s2  and inject the result in  S  >>> s2 = ...\n>>> from numpy import fill_diagonal\n>>> fill_diagonal(S, s)\n>>> A2 = dot(U, dot(S, Vh))",
            "title": "Reconstruction"
        },
        {
            "location": "/svd/#the-new-api",
            "text": "The redesigned  svd  function now has arguably a simpler and more consistent\ninterface:    The simplest and most common usage follows closely the domain conventions,    The \"configurable return values\" pattern is supported\n     with the extra parameter  returns    The ad hoc parameter  compute_uv  is not needed anymore.    Two helper functions  svdvals  and  diagsvd  are not needed anymore     The description of parameters and returned values is only slightly different 2 :   Parameters    a :  (M, N)  array_like  Matrix to decompose.    ...     returns :  string , optional   Select the returned values, among  U ,  S ,  s ,  V  and  Vh .\nDefault is  \"U, S, V\" .      Returns  The selection of return values is configurable with the  returns  parameter.    U :  ndarray  Unitary matrix having left singular vectors as columns.    S  :  ndarray  A matrix with the singular values of  a , sorted in non-increasing\norder, in the main diagonal and zeros elsewhere.    V :  ndarray  Unitary matrix having right singular vectors as columns.    s :  ndarray , not returned by default  The singular values, sorted in non-increasing order.    Vh :  ndarray , not returned by default  Conjugate transpose of  V           For example, if    >>> A = [[ 0.0, -2.0,  0.0],\n  ...      [ 1.0,  0.0,  0.0]]  then     >>> U\n  array([[1.,  0.],\n        [ 0.,  1.]])\n  >>> s \n  array([ 2.,  1.])\n  >>> Vh \n  array([[ 0., -1.,  0.],\n         [ 1.,  0.,  0.],\n         [ 0.,  0.,  1.]])  \u21a9    we have omitted any reference to the the parameters \n   full_matrices ,  overwrite_a ,  check_finite  and  lapack_driver  \n  since the behavior of  svd  has not changed in this respect.\n  Refer to the  Scipy documentation  for details.\u00a0 \u21a9",
            "title": "The New API"
        },
        {
            "location": "/reference/",
            "text": "[TODO]",
            "title": "Reference"
        }
    ]
}
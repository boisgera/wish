{
    "docs": [
        {
            "location": "/",
            "text": "Wish brings \nselectable return values\n to Python.\n\n\nOverview\n\u00b6\n\n\nIt's already very easy to deal with functions\nhaving several possible sets of arguments in Python.\nWhy? Because the language supports natively:\n\n\n\n\ndefault argument values\n\n\nkeyword arguments\n\n\nargument unpacking\n\n\n\n\nNow for return values, beyond tuples to deal with multiple values, \nPython provides actually little constructs. \nUsing functions that return many values is often tedious.\nWish provides selectable return values to solve this issue.\n\n\nQuickstart\n\u00b6\n\n\n\n\n\n\nInstall wish with pip (\ninstructions\n).\n\n\n\n\n\n\nReplace your function with many arguments \nf\n\n\ndef f(...):\n    ...\n    return a, b, c, ..., z\n\n\n\nwith\n\n\nimport wish\n\ndef f(..., returns=\"a, b\"):\n    ...\n    return wish.grant(returns)\n\n\n\n\n\n\n\nUpdate the documentation of your function\n\n\n\n\nParameters:\n\n\n\n\n\n\n...\n\n\n\n\n\n\nreturns\n: string, optional.\n    Select the returned values, among \na\n, \nb\n, ..., \nz\n.\n    Default is \n\"a, b\"\n.\n\n\n\n\n\n\nReturns:\n\n\n\n\n\n\na\n: ...\n\n\n\n\n\n\nb\n: ...\n\n\n\n\n\n\nc\n: ..., not returned by default\n\n\n\n\n\n\n...\n\n\n\n\n\n\nz\n: ..., not returned by default\n\n\n\n\n\n\n\n\n\n\n\n\nUse the flexibility of the new API\n\n\n >>> a, b = f(...)\n >>> w, i, s, h = f(..., returns=\"w, i, s, h\")",
            "title": "Getting Started"
        },
        {
            "location": "/#overview",
            "text": "It's already very easy to deal with functions\nhaving several possible sets of arguments in Python.\nWhy? Because the language supports natively:   default argument values  keyword arguments  argument unpacking   Now for return values, beyond tuples to deal with multiple values, \nPython provides actually little constructs. \nUsing functions that return many values is often tedious.\nWish provides selectable return values to solve this issue.",
            "title": "Overview"
        },
        {
            "location": "/#quickstart",
            "text": "Install wish with pip ( instructions ).    Replace your function with many arguments  f  def f(...):\n    ...\n    return a, b, c, ..., z  with  import wish\n\ndef f(..., returns=\"a, b\"):\n    ...\n    return wish.grant(returns)    Update the documentation of your function   Parameters:    ...    returns : string, optional.\n    Select the returned values, among  a ,  b , ...,  z .\n    Default is  \"a, b\" .    Returns:    a : ...    b : ...    c : ..., not returned by default    ...    z : ..., not returned by default       Use the flexibility of the new API   >>> a, b = f(...)\n >>> w, i, s, h = f(..., returns=\"w, i, s, h\")",
            "title": "Quickstart"
        },
        {
            "location": "/installation/",
            "text": "Python 2\n\u00b6\n\n\nWish supports Python 2.7.\nMake sure that the \npip\n package installer is available \nfor this version of the interpreter\n\n\n$ pip --version\npip 9.0.1 from /usr/local/lib/python2.7/dist-packages (python 2.7)\n\n\n\nand install wish\n\n\n$ pip install wish\n\n\n\nPython 3\n\u00b6\n\n\n\n\nWarning\n\n\nWish does not support Python 3 (yet).\n\n\n\n\nIf you want to install wish (for Python 2) but \npip\n refers to your Python 3 \ninterpreter\n\n\n$ pip --version\npip 9.0.1 from /usr/local/lib/python3.5/dist-packages (python 3.5)\n\n\n\nthen you may have a version of pip for Python 2 installed.\nIt may be named \npip2\n or \npip2.7\n; you can use it to install wish.\nOtherwise, refer to your Python 2 interpreter explicitly: \nif it is named \npython\n\n\n$ python --version\nPython 2.7.12\n\n\n\nthen install pip for Python 2 with\n\n\n$ python -m pip install --upgrade pip\n\n\n\nand finally install wish\n\n\n$ python -m pip install wish",
            "title": "Installation"
        },
        {
            "location": "/installation/#python-2",
            "text": "Wish supports Python 2.7.\nMake sure that the  pip  package installer is available \nfor this version of the interpreter  $ pip --version\npip 9.0.1 from /usr/local/lib/python2.7/dist-packages (python 2.7)  and install wish  $ pip install wish",
            "title": "Python 2"
        },
        {
            "location": "/installation/#python-3",
            "text": "Warning  Wish does not support Python 3 (yet).   If you want to install wish (for Python 2) but  pip  refers to your Python 3 \ninterpreter  $ pip --version\npip 9.0.1 from /usr/local/lib/python3.5/dist-packages (python 3.5)  then you may have a version of pip for Python 2 installed.\nIt may be named  pip2  or  pip2.7 ; you can use it to install wish.\nOtherwise, refer to your Python 2 interpreter explicitly: \nif it is named  python  $ python --version\nPython 2.7.12  then install pip for Python 2 with  $ python -m pip install --upgrade pip  and finally install wish  $ python -m pip install wish",
            "title": "Python 3"
        },
        {
            "location": "/numerical-differentiation/",
            "text": "The Classic API\n\u00b6\n\n\nConsider the following use case: the computation of the\n(approximate) derivative of a function with Newton's difference quotient:\n\n\ndef d(f, x, h=1e-13):\n    dq = (f(x + h) - f(x)) / h\n    return dq\n\n\n\nThis function \nd\n would typically be used like this:\n\n\n>>> from math import sin\n>>> d(sin, x=0.0)\n0.9999999999999983\n\n\n\nNow, an improved version of \nd\n would compute an error estimate \nerror\n\n\ndef d(f, x, h=1e-7):\n    dq = (f(x + h) - f(x)) / h\n    dq2 = (f(x + 0.5*h) - f(x)) / (0.5*h)\n    error = 2 * (dq - dq2)\n    return dq, error\n\n\n\nwhose usage would be\n\n\n>>> d(sin, x=0.0)\n(0.9999999999999983, -2.4424906541753444e-15)\n\n\n\nWhile this is a sound idea to provide an error estimate, \nwe have broken the original API. \nNow, in the simplest and more common use case,\nwhen we do not care about the error, \nthe code is more complex than it should be:\n\n\n>>> dq, _ = d(sin, x=0.0)\n>>> dq \n0.9999999999999983\n\n\n\nWe have used the underscore instead of \nerror\n for the second \nreturned value: in the classic approach, this is the standard \nway to signal this value will be ignored.\n\n\nWith Wish\n\u00b6\n\n\nTo get a decent API in both cases, we may use wish and\nspecify in the function signature an extra argument that lists the value(s) \nreturned by default\n\n\ndef d(f, x, h=1e-7, returns=\"dq\"):\n    dq = (f(x + h) - f(x)) / h\n    dq2 = (f(x + 0.5*h) - f(x)) / (0.5*h)\n    error = 2 * (dq - dq2)\n    return wish.grant(returns)\n\n\n\nWith this pattern, the common case is still simple\n\n\n>>> d(sin, x=0.0)\n0.9999999999999983\n\n\n\nbut the more complex case is possible and the intent is explicit:\n\n\n>>> d(sin, x=0.0, returns=\"dq, error\")\n(0.9999999999999983, -2.4424906541753444e-15)",
            "title": "Numerical Differentiation"
        },
        {
            "location": "/numerical-differentiation/#the-classic-api",
            "text": "Consider the following use case: the computation of the\n(approximate) derivative of a function with Newton's difference quotient:  def d(f, x, h=1e-13):\n    dq = (f(x + h) - f(x)) / h\n    return dq  This function  d  would typically be used like this:  >>> from math import sin\n>>> d(sin, x=0.0)\n0.9999999999999983  Now, an improved version of  d  would compute an error estimate  error  def d(f, x, h=1e-7):\n    dq = (f(x + h) - f(x)) / h\n    dq2 = (f(x + 0.5*h) - f(x)) / (0.5*h)\n    error = 2 * (dq - dq2)\n    return dq, error  whose usage would be  >>> d(sin, x=0.0)\n(0.9999999999999983, -2.4424906541753444e-15)  While this is a sound idea to provide an error estimate, \nwe have broken the original API. \nNow, in the simplest and more common use case,\nwhen we do not care about the error, \nthe code is more complex than it should be:  >>> dq, _ = d(sin, x=0.0)\n>>> dq \n0.9999999999999983  We have used the underscore instead of  error  for the second \nreturned value: in the classic approach, this is the standard \nway to signal this value will be ignored.",
            "title": "The Classic API"
        },
        {
            "location": "/numerical-differentiation/#with-wish",
            "text": "To get a decent API in both cases, we may use wish and\nspecify in the function signature an extra argument that lists the value(s) \nreturned by default  def d(f, x, h=1e-7, returns=\"dq\"):\n    dq = (f(x + h) - f(x)) / h\n    dq2 = (f(x + 0.5*h) - f(x)) / (0.5*h)\n    error = 2 * (dq - dq2)\n    return wish.grant(returns)  With this pattern, the common case is still simple  >>> d(sin, x=0.0)\n0.9999999999999983  but the more complex case is possible and the intent is explicit:  >>> d(sin, x=0.0, returns=\"dq, error\")\n(0.9999999999999983, -2.4424906541753444e-15)",
            "title": "With Wish"
        },
        {
            "location": "/svd/",
            "text": "We redesign the API of the SVD function of SciPy with wish.\n\n\n\n\nWarning\n\n\nThis example requires having \nNumPy\n and\n\nSciPy\n installed.\n\n\n\n\nContext\n\u00b6\n\n\nThe \nSciPy\n library \nimplements \nsingular value decomposition\n\n(SVD),\na matrix factorization that is instrumental\nin numerical analysis, machine learning and data science.\n\n\nThe SVD of a matrix \nA\n provides three matrices \nU\n, \nSigma\n\nand \nV\n.\nThe matrix \nS\n has the same shape as \nA\n and is diagonal \n(\nS[i,j] == 0\n unless \ni == j\n). The matrices \nU\n and \nV\n are unitary. \nRefer for example to \nSVD on Wikipedia\n\nfor more information.\n\n\nIn any case, to compute \nA\n from \nU\n, \nS\n and \nV\n, do:\n\n\n>>> from numpy import dot\n>>> Vh = V.conjugate().transpose()\n>>> A = dot(U, dot(S, Vh))\n\n\n\n\n\n\nBasic API\n\u00b6\n\n\nThe \nsvd\n function of SciPy works like this: you provide the matrix \nA\n\nand it computes a matrix \nU\n, a vector \ns\n and a matrix \nVh\n1\n:\n\n\n>>> from scipy.linalg import svd\n>>> U, s, Vh = svd(A)\n\n\n\nThe default convention deviates a little from the definition of the SVD:\nthe vector \ns\n is the diagonal of \nS\n instead of \nS\n itself\nand \nVh\n corresponds to the conjugate transpose of \nV\n instead of \nV\n.\n\n\nWhile there are good reasons for these conventions, \nI'd rather follow the \nprinciple of least astonishment\n.\nThus, by default our SVD\nimplementation returns the triple \n(U, S, V)\n:\n\n\n>>> from wish.examples import svd\n>>> U, S, V = svd(A)\n\n\n\nSay that our starting point is\n\n\ndef svd(A):\n    U, S, V = ...\n    return U, S, V\n\n\n\nTo enable the simplest version of selectable return values, \nwe change the code to:\n\n\nimport wish\n\ndef svd(A, returns=\"U, S, V\"):\n    U, S, V = ... \n    return wish.grant(returns)\n\n\n\nIf you want to check the names that the user requires, do instead\n\n\ndef svd(A, returns=\"U, S, V\"):\n    wishlist = wish.make(returns)\n    for name in wishlist:\n        if name not in [\"U\", \"S\", \"V\"]:\n             error = \"{0!r} is not a valid return value\"\n             raise NameError(error.format(name))\n    U, S, V = ... \n    return wishlist.grant()\n\n\n\nNow, we believe that it should be possible to get the same output of SciPy. \nTt's rather simple since we have enabled selectable return values:\n\n\n>>> U, s, Vh = svd(A, returns=\"U, s, Vh\")\n\n\n\nThe corresponding implementation is:\n\n\nimport numpy\nimport wish\n\ndef svd(A, returns=\"U, S, V\"):\n    wishlist = wish.make(returns)\n    for name in wishlist:\n        if name not in [\"U\", \"S\", \"V\", \"s\", \"Vh\"]:\n             error = \"{0!r} is not a valid return value\"\n             raise NameError(error.format(name))\n    U, S, V = ... \n    if \"s\" in wishlist:\n        s = numpy.diagonal(S)\n    if \"Vh\" in wishlist:\n        Vh = V.conjugate().transpose()\n    return wishlist.grant()\n\n\n\nSingular Values\n\u00b6\n\n\nWe frequently need to compute only the singular values of a matrix.\nThe scipy \nsvd\n achieves this with an additional option \ncompute_uv\n \nthat can be set to \nFalse\n as describe in the documentation:\n\n\n\n\ncompute_uv: bool, optional.\n\n\nWhether to compute also \nU\n and \nVh\n in addition to \ns\n.\nDefault is True.\n\n\n\n\nIt is used like this:\n\n\n>>> from scipy.linalg import svd\n>>> s = svd(M, compute_uv=False)\n\n\n\nThis interface is not totally satisfactory: \nwhile we easily understand that we won't \ncompute -- and therefore won't return -- \nU\n and \nVh\n, \nit is not totally obvious what is returned. \nAnd if in the first place you were only interested \nin the \ns\n array, you may not know what \nU\n and \nVh\n are ...\nThere is nothing here that cannot be solved by reading \nthe documentation of \nsvd\n, but still this is not optimal.\nThe SciPy folks are apparently aware of this because they have implemented \na helper function, \nsvdvals\n, to avoid calling \nsvd\n in this case:\n\n\n\n\nsvdvals(a, overwrite_a=False, check_finite=True)\n\n\nCompute singular values of a matrix.\n\n\n\n\nWith \nsvdvals\n, we can simply do\n\n\n>>> from scipy.linalg import svdvals\n>>> s = svdvals(A)\n\n\n\nbut of course now, you have another function to remember of.\nAnd while it is a one-liner, its full documentation essentially \nduplicates the one of \nsvd\n.\n\n\nWith the wish version, the equivalent function call is simply\n\n\n>>> from wish.examples import svd\n>>> s = svd(A, returns=\"s\")\n\n\n\nWe know what is returned and a no new function is necessary.\n\n\nNow, if we have a simpler algorithm to provide only \nS\n,\nwe may check the list of wishes and proceed accordingly:\n\n\nimport numpy\nimport wish\n\ndef svd(A, returns=\"U, S, V\"):\n    wishlist = wish.make(returns)\n    for name in wishlist:\n        if name not in [\"U\", \"S\", \"V\", \"s\", \"Vh\"]:\n             error = \"{0!r} is not a valid return value\"\n             raise NameError(error.format(name))\n\n    if \"U\" in wishlist or \"V\" in wishlist or \"Vh\" in wishlist:\n        U, S, V = ... \n    else:\n        S = ...\n\n    if \"s\" in wishlist:\n        s = numpy.diagonal(S)\n    if \"Vh\" in wishlist:\n        Vh = V.conjugate().transpose()\n\n    return wishlist.grant()\n\n\n\nReconstruction\n\u00b6\n\n\nSince SciPy \nsvd\n returns the diagonal \ns\n of \nS\n instead of \nS\n itself, \nit comes with the helper function \ndiagsvd\n to build\n\nS\n from the singular values:\n\n\n\n\ndiagsvd(s, M, N)\n\n\nConstruct the sigma matrix in SVD from singular values and size \nM\n, \nN\n.\n\n\n\n\nIt is used like this:\n\n\n>>> U, s, Vh = svd(A)\n>>> S = diagsvd(s, shape(U)[1], shape(Vh)[0])\n\n\n\nThe matrix \nS\n is typically used to reconstruct \nA\n:\n\n\n>>> from numpy import dot\n>>> A = dot(U, dot(S, Vh))\n\n\n\nOf course with the wish-enabled version, the same effect is obtained with\n\n\n>>> from wish.examples import svd\n>>> U, S, Vh = wsvd(A, returns=\"U, S, Vh\")\n>>> A = dot(U, dot(S, Vh))\n\n\n\n\n\nNow, if you don't want to reconstruct the matrix \nA\n but a version of it\nbased on a different set of singular values -- for example to achieve\nsome \ndimensionality reduction\n \n-- this is easy because NumPy already provides \nthe appropriate functions. First, get the singular values with\n\n\n>>> U, S, Vh, s = w_svd(A, returns=\"U, S, Vh, s\")\n\n\n\nthen replace the vector of singular values \ns\n\nwith a modified vector \ns2\n and inject the result in \nS\n\n\n>>> s2 = ...\n>>> from numpy import fill_diagonal\n>>> fill_diagonal(S, s)\n>>> A2 = dot(U, dot(S, Vh))\n\n\n\nThe New API\n\u00b6\n\n\nThe redesigned \nsvd\n function now has arguably a simpler and more consistent\ninterface:\n\n\n\n\n\n\nThe simplest and most common usage follows closely the domain conventions,\n\n\n\n\n\n\nThe \"configurable return values\" pattern is supported\n     with the extra parameter \nreturns\n\n\n\n\n\n\nThe ad hoc parameter \ncompute_uv\n is not needed anymore.\n\n\n\n\n\n\nTwo helper functions \nsvdvals\n and \ndiagsvd\n are not needed anymore\n\n\n\n\n\n\n\n\n\nThe description of parameters and returned values is only slightly different\n2\n:\n\n\n\n\nParameters\n\n\n\n\n\n\nA\n: \n(M, N)\n array_like\n\n\nMatrix to decompose.\n\n\n\n\n\n\n... \n\n\n\n\n\n\nreturns\n: \nstring\n, optional \n\n\nSelect the returned values, among \nU\n, \nS\n, \ns\n, \nV\n and \nVh\n.\nDefault is \n\"U, S, V\"\n.\n\n\n\n\n\n\n\n\n\n\nReturns\n\n\nThe selection of return values is configurable with the \nreturns\n parameter.\n\n\n\n\n\n\nU\n: \nndarray\n\n\nUnitary matrix having left singular vectors as columns.\n\n\n\n\n\n\nS\n : \nndarray\n\n\nA matrix with the singular values of \nA\n, sorted in non-increasing\norder, in the main diagonal and zeros elsewhere.\n\n\n\n\n\n\nV\n: \nndarray\n\n\nUnitary matrix having right singular vectors as columns.\n\n\n\n\n\n\ns\n: \nndarray\n, not returned by default\n\n\nThe singular values, sorted in non-increasing order.\n\n\n\n\n\n\nVh\n: \nndarray\n, not returned by default\n\n\nConjugate transpose of \nV\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFor example, if\n\n\n  >>> A = [[ 0.0, -2.0,  0.0],\n  ...      [ 1.0,  0.0,  0.0]]\n\n\n\nthen \n\n\n  >>> U\n  array([[1.,  0.],\n        [ 0.,  1.]])\n  >>> s \n  array([ 2.,  1.])\n  >>> Vh \n  array([[ 0., -1.,  0.],\n         [ 1.,  0.,  0.],\n         [ 0.,  0.,  1.]])\n\n\n\n\u21a9\n\n\n\n\n\n\nwe have omitted any reference to the the parameters \n  \nfull_matrices\n, \noverwrite_a\n, \ncheck_finite\n and \nlapack_driver\n \n  since the behavior of \nsvd\n has not changed in this respect.\n  Refer to the \nScipy documentation\n for details.\u00a0\n\u21a9",
            "title": "Singular Value Decomposition"
        },
        {
            "location": "/svd/#context",
            "text": "The  SciPy  library \nimplements  singular value decomposition \n(SVD),\na matrix factorization that is instrumental\nin numerical analysis, machine learning and data science.  The SVD of a matrix  A  provides three matrices  U ,  Sigma \nand  V .\nThe matrix  S  has the same shape as  A  and is diagonal \n( S[i,j] == 0  unless  i == j ). The matrices  U  and  V  are unitary. \nRefer for example to  SVD on Wikipedia \nfor more information.  In any case, to compute  A  from  U ,  S  and  V , do:  >>> from numpy import dot\n>>> Vh = V.conjugate().transpose()\n>>> A = dot(U, dot(S, Vh))",
            "title": "Context"
        },
        {
            "location": "/svd/#basic-api",
            "text": "The  svd  function of SciPy works like this: you provide the matrix  A \nand it computes a matrix  U , a vector  s  and a matrix  Vh 1 :  >>> from scipy.linalg import svd\n>>> U, s, Vh = svd(A)  The default convention deviates a little from the definition of the SVD:\nthe vector  s  is the diagonal of  S  instead of  S  itself\nand  Vh  corresponds to the conjugate transpose of  V  instead of  V .  While there are good reasons for these conventions, \nI'd rather follow the  principle of least astonishment .\nThus, by default our SVD\nimplementation returns the triple  (U, S, V) :  >>> from wish.examples import svd\n>>> U, S, V = svd(A)  Say that our starting point is  def svd(A):\n    U, S, V = ...\n    return U, S, V  To enable the simplest version of selectable return values, \nwe change the code to:  import wish\n\ndef svd(A, returns=\"U, S, V\"):\n    U, S, V = ... \n    return wish.grant(returns)  If you want to check the names that the user requires, do instead  def svd(A, returns=\"U, S, V\"):\n    wishlist = wish.make(returns)\n    for name in wishlist:\n        if name not in [\"U\", \"S\", \"V\"]:\n             error = \"{0!r} is not a valid return value\"\n             raise NameError(error.format(name))\n    U, S, V = ... \n    return wishlist.grant()  Now, we believe that it should be possible to get the same output of SciPy. \nTt's rather simple since we have enabled selectable return values:  >>> U, s, Vh = svd(A, returns=\"U, s, Vh\")  The corresponding implementation is:  import numpy\nimport wish\n\ndef svd(A, returns=\"U, S, V\"):\n    wishlist = wish.make(returns)\n    for name in wishlist:\n        if name not in [\"U\", \"S\", \"V\", \"s\", \"Vh\"]:\n             error = \"{0!r} is not a valid return value\"\n             raise NameError(error.format(name))\n    U, S, V = ... \n    if \"s\" in wishlist:\n        s = numpy.diagonal(S)\n    if \"Vh\" in wishlist:\n        Vh = V.conjugate().transpose()\n    return wishlist.grant()",
            "title": "Basic API"
        },
        {
            "location": "/svd/#singular-values",
            "text": "We frequently need to compute only the singular values of a matrix.\nThe scipy  svd  achieves this with an additional option  compute_uv  \nthat can be set to  False  as describe in the documentation:   compute_uv: bool, optional.  Whether to compute also  U  and  Vh  in addition to  s .\nDefault is True.   It is used like this:  >>> from scipy.linalg import svd\n>>> s = svd(M, compute_uv=False)  This interface is not totally satisfactory: \nwhile we easily understand that we won't \ncompute -- and therefore won't return --  U  and  Vh , \nit is not totally obvious what is returned. \nAnd if in the first place you were only interested \nin the  s  array, you may not know what  U  and  Vh  are ...\nThere is nothing here that cannot be solved by reading \nthe documentation of  svd , but still this is not optimal.\nThe SciPy folks are apparently aware of this because they have implemented \na helper function,  svdvals , to avoid calling  svd  in this case:   svdvals(a, overwrite_a=False, check_finite=True)  Compute singular values of a matrix.   With  svdvals , we can simply do  >>> from scipy.linalg import svdvals\n>>> s = svdvals(A)  but of course now, you have another function to remember of.\nAnd while it is a one-liner, its full documentation essentially \nduplicates the one of  svd .  With the wish version, the equivalent function call is simply  >>> from wish.examples import svd\n>>> s = svd(A, returns=\"s\")  We know what is returned and a no new function is necessary.  Now, if we have a simpler algorithm to provide only  S ,\nwe may check the list of wishes and proceed accordingly:  import numpy\nimport wish\n\ndef svd(A, returns=\"U, S, V\"):\n    wishlist = wish.make(returns)\n    for name in wishlist:\n        if name not in [\"U\", \"S\", \"V\", \"s\", \"Vh\"]:\n             error = \"{0!r} is not a valid return value\"\n             raise NameError(error.format(name))\n\n    if \"U\" in wishlist or \"V\" in wishlist or \"Vh\" in wishlist:\n        U, S, V = ... \n    else:\n        S = ...\n\n    if \"s\" in wishlist:\n        s = numpy.diagonal(S)\n    if \"Vh\" in wishlist:\n        Vh = V.conjugate().transpose()\n\n    return wishlist.grant()",
            "title": "Singular Values"
        },
        {
            "location": "/svd/#reconstruction",
            "text": "Since SciPy  svd  returns the diagonal  s  of  S  instead of  S  itself, \nit comes with the helper function  diagsvd  to build S  from the singular values:   diagsvd(s, M, N)  Construct the sigma matrix in SVD from singular values and size  M ,  N .   It is used like this:  >>> U, s, Vh = svd(A)\n>>> S = diagsvd(s, shape(U)[1], shape(Vh)[0])  The matrix  S  is typically used to reconstruct  A :  >>> from numpy import dot\n>>> A = dot(U, dot(S, Vh))  Of course with the wish-enabled version, the same effect is obtained with  >>> from wish.examples import svd\n>>> U, S, Vh = wsvd(A, returns=\"U, S, Vh\")\n>>> A = dot(U, dot(S, Vh))   Now, if you don't want to reconstruct the matrix  A  but a version of it\nbased on a different set of singular values -- for example to achieve\nsome  dimensionality reduction  \n-- this is easy because NumPy already provides \nthe appropriate functions. First, get the singular values with  >>> U, S, Vh, s = w_svd(A, returns=\"U, S, Vh, s\")  then replace the vector of singular values  s \nwith a modified vector  s2  and inject the result in  S  >>> s2 = ...\n>>> from numpy import fill_diagonal\n>>> fill_diagonal(S, s)\n>>> A2 = dot(U, dot(S, Vh))",
            "title": "Reconstruction"
        },
        {
            "location": "/svd/#the-new-api",
            "text": "The redesigned  svd  function now has arguably a simpler and more consistent\ninterface:    The simplest and most common usage follows closely the domain conventions,    The \"configurable return values\" pattern is supported\n     with the extra parameter  returns    The ad hoc parameter  compute_uv  is not needed anymore.    Two helper functions  svdvals  and  diagsvd  are not needed anymore     The description of parameters and returned values is only slightly different 2 :   Parameters    A :  (M, N)  array_like  Matrix to decompose.    ...     returns :  string , optional   Select the returned values, among  U ,  S ,  s ,  V  and  Vh .\nDefault is  \"U, S, V\" .      Returns  The selection of return values is configurable with the  returns  parameter.    U :  ndarray  Unitary matrix having left singular vectors as columns.    S  :  ndarray  A matrix with the singular values of  A , sorted in non-increasing\norder, in the main diagonal and zeros elsewhere.    V :  ndarray  Unitary matrix having right singular vectors as columns.    s :  ndarray , not returned by default  The singular values, sorted in non-increasing order.    Vh :  ndarray , not returned by default  Conjugate transpose of  V           For example, if    >>> A = [[ 0.0, -2.0,  0.0],\n  ...      [ 1.0,  0.0,  0.0]]  then     >>> U\n  array([[1.,  0.],\n        [ 0.,  1.]])\n  >>> s \n  array([ 2.,  1.])\n  >>> Vh \n  array([[ 0., -1.,  0.],\n         [ 1.,  0.,  0.],\n         [ 0.,  0.,  1.]])  \u21a9    we have omitted any reference to the the parameters \n   full_matrices ,  overwrite_a ,  check_finite  and  lapack_driver  \n  since the behavior of  svd  has not changed in this respect.\n  Refer to the  Scipy documentation  for details.\u00a0 \u21a9",
            "title": "The New API"
        }
    ]
}